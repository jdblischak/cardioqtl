# Snakefile

# To run on RCC Midway use `bash submit-snakemake.sh`

import glob
import os
from snakemake.utils import R

# Configuration ----------------------------------------------------------------

# Paths must end with forward slash
dir_proj = "/project2/gilad/jdblischak/cardioqtl/"
dir_data = dir_proj + "data/"
dir_fq = dir_data + "fastq/"
dir_kal = dir_data + "kallisto/"
scratch = "/scratch/midway2/jdblischak/"
dir_genome = scratch + "hg38/"
dir_fq_tmp = scratch + "cardioqtl-fastq/"
dir_bam = scratch + "cardioqtl-bam/"
dir_counts = scratch + "cardioqtl-counts/"
dir_vcf = dir_data + "vcf/"
dir_id = dir_data + "id/"

f_transcripts_fa =  scratch + "transcriptome-ensembl-GRCh38-rel79.fa.gz"
f_transcripts_idx =  scratch + "transcriptome-ensembl-GRCh38-rel79.idx"

assert os.path.exists(dir_proj), "Project directory exists"
assert os.path.exists(scratch), "Scratch directory exists"

for d in [dir_data, dir_fq, dir_kal, dir_genome,
          dir_fq_tmp, dir_bam, dir_counts, dir_vcf,
          dir_id]:
    if not os.path.isdir(d):
        os.mkdir(d)

# http://mar2015.archive.ensembl.org/index.html
ensembl_archive = "mar2015.archive.ensembl.org"
ensembl_rel = "rel79"

chromosomes = [str(x) for x in range(1, 23)] + ["X", "Y", "M"]

# Input samples ----------------------------------------------------------------

#files_fq = glob.glob(dir_fq + "*fastq.gz")
#samples = [os.path.basename(x).split("-")[0] for x in files_fq]

samples = set(glob_wildcards(dir_fq + "{samples}-H{flow_cell}-l{lane}.fastq.gz").samples)

# Functions --------------------------------------------------------------------

# Find all fastq.gz files for a given sample.
# Inspired by this post on the Snakemake Google Group:
# https://groups.google.com/forum/#!searchin/snakemake/multiple$20input$20files%7Csort:relevance/snakemake/bpTnr7FgDuQ/ybacyom6BQAJ
def merge_fastq(wc):
    suffixes = glob_wildcards(dir_fq + "{s}-{{suffix}}.fastq.gz".format(s=wc.sample)).suffix
#    import pdb; pdb.set_trace()
    files = expand(dir_fq + "{s}-{{suffix}}.fastq.gz".format(s=wc.sample),
                   suffix = suffixes)
    return files

# Targets ----------------------------------------------------------------------

rule quantify_expression:
    input:  dir_data + "gene-exp-all.txt"

rule run_kallisto:
    input: expand(dir_kal + "{sample}/abundance.tsv", sample = samples)

rule prepare_kallisto:
    input: f_transcripts_idx

rule run_verifyBamID:
    input: expand(dir_id + "{sample}.bestSM", sample = samples)

rule run_featureCounts:
    input: expand(dir_counts + "{sample}.genecounts.txt", sample = samples)

rule run_subjunc:
    input: expand(dir_bam + "{sample}.bam", sample = samples)

rule prepare_subjunc:
    input: dir_genome + "hg38.reads"

# Quanitfy expression with kallisto --------------------------------------------

# This is release 79 from 2015-03. Should eventually update to release
# 86 from 2016-10.
rule download_transcriptome:
    output: f_transcripts_fa
    shell: "wget -O {output} http://bio.math.berkeley.edu/kallisto/transcriptomes/Homo_sapiens.GRCh38.rel79.cdna.all.fa.gz"

rule kallisto_index:
    input:  f_transcripts_fa,
    output: f_transcripts_idx
    shell: "kallisto index -i {output} {input}"

rule kallisto_quant:
    input: read1 = merge_fastq,
           index = f_transcripts_idx
    output: dir_kal + "{sample}/abundance.tsv"
    params: outdir = dir_kal + "{sample}"
    threads: 8
    shell: "kallisto quant -i {input.index} -o {params.outdir} --single -l 200 -s 20 -t {threads} {input.read1}"

rule download_ensembl_info:
    output: dir_data + "ensembl-" + ensembl_rel + ".txt"
    shell: "Rscript download-ensembl-info.R {ensembl_archive} > {output}"

rule create_gene_exp_matrix:
    input: expand(dir_kal + "{sample}/abundance.tsv", sample = samples),
           ensembl = dir_data + "ensembl-" + ensembl_rel + ".txt"
    output: dir_data + "gene-exp-all.txt"
    shell: "Rscript create-gene-exp-matrix.R {input.ensembl} {dir_kal} > {output}"

# Quanitify expression with Subjunc/featureCounts ------------------------------

rule download_genome:
    output: dir_genome + "chr{chr}.fa.gz"
    params: chr = "{chr}"
    shell: "wget -O {output} http://hgdownload.cse.ucsc.edu/goldenPath/hg38/chromosomes/chr{params.chr}.fa.gz"

rule unzip_chromosome_fasta:
    input: dir_genome + "chr{chr}.fa.gz"
    output: temp(dir_genome + "chr{chr}.fa")
    shell: "zcat {input} > {output}"

rule subread_index:
    input: expand(dir_genome + "chr{chr}.fa", chr = chromosomes)
    output: dir_genome + "hg38.reads"
    params: prefix = dir_genome + "hg38"
    shell: "subread-buildindex -o {params.prefix} {input}"

rule combine_fastq:
    input: merge_fastq
    output: temp(dir_fq_tmp + "{sample}.fastq")
    shell: "zcat {input} > {output}"

rule subjunc:
    input: read = dir_fq_tmp + "{sample}.fastq",
           index = dir_genome + "hg38.reads"
    output: dir_bam + "{sample}.bam"
    params: prefix = dir_genome + "hg38"
    threads: 8
    shell: "subjunc -i {params.prefix} -r {input.read} -u -T {threads} > {output}"

rule create_exons_saf:
    output: dir_genome + "exons.saf"
    shell: "Rscript create-exons.R {ensembl_archive} >  {output}"

rule feauturecounts:
    input: bam = dir_bam + "{sample}.bam",
           exons = dir_genome + "exons.saf"
    output: dir_counts + "{sample}.genecounts.txt"
    threads: 8
    shell: "featureCounts -a {input.exons} -F SAF -T {threads} -o {output} {input.bam}"

# Verify identity with verifyBamID ---------------------------------------------

# Convert exons in SAF format to BED format. Duplicate exons are maintained.
rule convert_to_bed:
    input: saf = dir_genome + "exons.saf"
    output: bed = dir_genome + "exons.bed"
    run:
        saf = open(input.saf, "r")
        bed = open(output.bed, "w")
        # Discard header
        saf.readline()

        for line in saf:
            cols = line.strip().split("\t")
            id = cols[0]
            chr = cols[1]
            start = str(int(cols[2]) - 1)
            end = cols[3]
            strand = cols[4]
            entry = "%s\t%s\t%s\t%s\t%s\t%s\n"%(chr, start, end, id, 0, strand)
            bed.write(entry)

        saf.close()
        bed.close()

# Select only those SNPs in annotated exons of protein-coding genes
rule select_exonic_snps:
    input: vcf = dir_vcf + "dox-hg38-chr{CHR}.vcf.gz",
           exons = dir_genome + "exons.bed"
    output: vcf = temp(dir_vcf + "dox-hg38-chr{CHR}-exons.vcf")
    shell: "bedtools intersect -a {input.vcf} -b {input.exons} -u -header > {output.vcf}"

# Combine exonic SNPs into one file
rule combine_snps:
    input: vcf = expand(dir_vcf  + "dox-hg38-chr{CHR}-exons.vcf", CHR = chromosomes[:-3])
    output: vcf = dir_vcf + "dox-hg38-exons.vcf"
    shell: "cat <(head -n 1 {input.vcf[0]}) <(cat {input.vcf} | grep -v CHROM) > {output.vcf}"

# Run verifyBamID to obtain the best individual match for the BAM file
rule verify_bam:
    input: vcf =  dir_vcf + "dox-hg38-exons.vcf",
         bam = dir_bam + "{sample}.bam"
    output: dir_id + "{sample}.bestSM"
    params: prefix = dir_id + "{sample}",
            individual = "{sample}"
    shell: "verifyBamID --vcf {input.vcf} --bam {input.bam} --best --ignoreRG --smID {params.individual} --out {params.prefix}"
